#pragma kernel CSMain

#pragma multi_compile __ USE_SKYBOX
#pragma multi_compile __ USE_RR
#pragma multi_compile __ HAS_SPHERE
#pragma multi_compile __ HAS_MESH

#include "PathTracingUtils.hlsl"

RWTexture2D<float4> Result;
TextureCube _SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;

int _frameCount;
int _cameraType;
int _useSkybox;
float3 _skyColor;
int _bouncesCount;
float _RR;

StructuredBuffer<Sphere> SphereBuffer;
StructuredBuffer<Triangle> TriangleBuffer;
StructuredBuffer<Mesh> MeshBuffer;
StructuredBuffer<BVHNode> BVHNodeBuffer;

Texture2D BaseMap;
Texture2D NormalMap;
Texture2D ARMMap;

SamplerState sampler_BaseMap;
SamplerState sampler_NormalMap;
SamplerState sampler_ARMMap;

// #define HAS_MESH
// #define HAS_SPHERE
void TraceRay(Ray ray, inout HitPayload payload)
{
    uint listCount, stride;

    #ifdef HAS_SPHERE
    SphereBuffer.GetDimensions(listCount, stride);

    for (uint j = 0; j < listCount; j++)
    {
        Sphere sphere = SphereBuffer[j];
        float t = SphereIntersection(sphere, ray);
        if (t < payload.closestT)
        {
            payload.closestT = t;
            payload.position = ray.origin + t * ray.direction;
            payload.geometricNormal = normalize(payload.position - sphere.center);
            payload.mat = sphere.mat;
        }
    }
    #endif

    #ifdef HAS_MESH
    MeshBuffer.GetDimensions(listCount, stride);

    for (uint k = 0; k < listCount; k++)
    {
        payload.hit = false;

        Mesh mesh = MeshBuffer[k];

        Ray transRay = RayWorldToObject(ray, mesh.nM);

        BVHNode node = BVHNodeBuffer[mesh.rootNode + mesh.nodeOffset];

        // node = BVHNodeBuffer[mesh.rootNode+0 + mesh.nodeOffset];
        //
        // AABBIntersection(node.AABBMin, node.AABBMax, transRay, payload, mesh.mat, mesh.M);
        // break;

        if (AABBIntersectionDst(node.AABBMin, node.AABBMax, transRay) >= payload.closestT)
            continue;

        int nodeStack[32];
        uint stackTop = 0;
        nodeStack[stackTop++] = mesh.rootNode + mesh.nodeOffset;

        while (stackTop > 0)
        {
            node = BVHNodeBuffer[nodeStack[--stackTop]];

            if (node.leftChild < 0)
            {
                // AABBIntersection(node.AABBMin, node.AABBMax, transRay, payload, mesh.mat, mesh.M);

                for (int z = node.triStart; z < node.triStart - node.leftChild; z++)
                {
                    uint osz = z + mesh.triOffset;

                    Triangle tri = TriangleBuffer[osz];

                    TriangleIntersection(tri, transRay, payload);

                    // TriObjectToWorld(tri, mesh.M, mesh.nM);
                    // TriangleIntersection(tri, ray, payload, mesh.mat);

                    // TriangleIntersection(tri, transRay, ray, payload, mesh.mat, mesh.nM);
                }
            }
            else
            {
                BVHNode leftChild = BVHNodeBuffer[node.leftChild + mesh.nodeOffset];
                BVHNode rightChild = BVHNodeBuffer[node.leftChild + 1 + mesh.nodeOffset];

                float dstA = AABBIntersectionDst(leftChild.AABBMin, leftChild.AABBMax, transRay);
                float dstB = AABBIntersectionDst(rightChild.AABBMin, rightChild.AABBMax, transRay);

                bool isNearestA = dstA <= dstB;
                float dstNear = isNearestA ? dstA : dstB;
                float dstFar = isNearestA ? dstB : dstA;
                int childIndexNear = isNearestA ? node.leftChild : node.leftChild + 1;
                int childIndexFar = isNearestA ? node.leftChild + 1 : node.leftChild;

                if (dstFar < payload.closestT)
                    nodeStack[stackTop++] = childIndexFar + mesh.nodeOffset;
                if (dstNear < payload.closestT)
                    nodeStack[stackTop++] = childIndexNear + mesh.nodeOffset;
            }
        }

        if (payload.hit && payload.closestT < FLT_MAX)
        {
            payload.geometricNormal = normalize(mul(mesh.nM, float4(payload.geometricNormal, 0)).xyz);
            payload.tangent = float4(normalize(mul(mesh.M, float4(payload.tangent.xyz, 0)).xyz), payload.tangent.w);
            payload.position = ray.origin + payload.closestT * ray.direction;
            payload.mat = mesh.mat;
        }
    }
    #endif
}

float3 Shade(Ray ray, uint2 id, uint width, uint height)
{
    float3 col = 0;
    float3 contribution = 1.0;

    uint bounces = _bouncesCount;
    uint stride = width * height * bounces;

    uint seed = (id.y * width + id.x) * bounces;
    seed += (_frameCount - 1) * stride;

    #ifdef USE_RR
    uint i = 0;
    while(true)
    #else
    for (uint i = 0; i < bounces; i++)
    #endif
    {
        seed += i;
        seed *= PCG_Hash(seed);

        #ifdef USE_RR
        float rand = RandomFloat(seed);
        if (rand < _RR)
        {
        #endif

        HitPayload payload = CreateHitPayload();
        TraceRay(ray, payload);

        if (payload.closestT < FLT_MAX)
        {
            if (payload.mat.enableEmission)
            {
                col += payload.mat.emissionColor * contribution;
                break;
            }

            float3 v = -ray.direction;


            if (payload.mat.texIndex)
            {
                payload.mat.baseColor = BaseMap.SampleLevel(sampler_BaseMap, payload.uv, 0).rgb;

                float3 tbnNormal = normalize(UnpackNormal(NormalMap.SampleLevel(sampler_NormalMap, payload.uv, 0)));
                payload.shadingNormal = ToWorld(tbnNormal, payload.geometricNormal, payload.tangent);
                if (dot(payload.shadingNormal, v) * dot(payload.geometricNormal, v) < 0 && abs(dot(payload.shadingNormal, v)) > 0.15)
                    payload.shadingNormal = -payload.shadingNormal;

                // payload.shadingNormal = payload.geometricNormal;

                float4 arm = ARMMap.SampleLevel(sampler_ARMMap, payload.uv, 0);
                payload.mat.roughness = arm.g;
                payload.mat.metallic = arm.b;
            }
            else
            {
                payload.shadingNormal = payload.geometricNormal;
            }

            float mis = MultipleImportanceSample(seed, v, payload.shadingNormal, payload.geometricNormal, payload.mat,
                                                 ray.direction);

            float3 bsdf = DisneyBSDF(payload.shadingNormal, payload.geometricNormal, v, ray.direction, payload.mat) *
                max(0, mis);

            contribution *= bsdf;

            float ngl = dot(payload.geometricNormal, ray.direction);

            float bias = ngl < 0 ? -1e-4 : 1e-4;
            ray.origin = payload.position + payload.geometricNormal * bias;
        }
        else
        {
            #ifdef USE_SKYBOX
            col += clamp(_SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, ray.direction, 0).rgb, 0, 300) * contribution;
            #else
            col += _skyColor * contribution;
            #endif
            break;
        }
        #ifdef USE_RR
        }
        else
        {
            col /= _RR;
            break;
        }
        i++;
        #endif
    }

    return col;
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    // Ray ray = CreateRay(uv);
    Ray ray = CreateRay(uv + GetSSAABias(16, _frameCount, width, height));
    // Ray ray = CreateRay(uv + GetJitterBias(_frameCount, width, height));
    float3 col = Shade(ray, id.xy, width, height);

    col = clamp(col, 0, 500);
    // col = max(col, 0);

    if (_cameraType == 1 && _frameCount > 1)
        col = lerp(Result[id.xy].rgb, col, 1.0f / _frameCount);


    Result[id.xy] = float4(col, 1);
}

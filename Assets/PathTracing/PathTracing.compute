#pragma kernel CSMain

#pragma multi_compile __ USE_SKYBOX
#pragma multi_compile __ USE_RR

#include "PathTracingUtils.hlsl"

RWTexture2D<float4> Result;
TextureCube _SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;

int _frameCount;
int _cameraType;
int _useSkybox;
float3 _skyColor;
int _bouncesCount;
float _RR;

StructuredBuffer<Sphere> SphereBuffer;
// StructuredBuffer<float3> VertexBuffer;
// StructuredBuffer<float3> NormalBuffer;
// StructuredBuffer<int> IndexBuffer;
StructuredBuffer<Triangle> TriangleBuffer;
StructuredBuffer<Mesh> MeshBuffer;
StructuredBuffer<BVHNode> BVHNodeBuffer;

// Texture2D Tex0[];
Texture2D Tex0;
// SamplerState Sampler0;

void TraceRay(Ray ray, inout HitPayload payload)
{
    uint listCount, stride;

    SphereBuffer.GetDimensions(listCount, stride);
    
    for (uint j = 0; j < listCount; j++)
    {
        Sphere sphere = SphereBuffer[j];
        float t = SphereIntersection(sphere, ray);
        if (t < payload.closestT)
        {
            payload.closestT = t;
            payload.position = ray.origin + t * ray.direction;
            payload.normal = normalize(payload.position - sphere.center);
            payload.mat = sphere.mat;
            // payload.inside = false;
        }
    }

    MeshBuffer.GetDimensions(listCount, stride);

    for (uint k = 0; k < listCount; k++)
    {
        payload.hit = false;

        Mesh mesh = MeshBuffer[k];

        Ray transRay = RayWorldToObject(ray, mesh.nM);

        BVHNode node = BVHNodeBuffer[mesh.rootNode + mesh.nodeOffset];

        // node = BVHNodeBuffer[mesh.rootNode+0 + mesh.nodeOffset];
        //
        // AABBIntersection(node.AABBMin, node.AABBMax, transRay, payload, mesh.mat, mesh.M);
        // break;

        if (AABBIntersectionDst(node.AABBMin, node.AABBMax, transRay) >= payload.closestT)
            continue;

        int nodeStack[32];
        uint stackTop = 0;
        nodeStack[stackTop++] = mesh.rootNode + mesh.nodeOffset;

        while (stackTop > 0)
        {
            node = BVHNodeBuffer[nodeStack[--stackTop]];

            if (node.leftChild < 0)
            {
                // AABBIntersection(node.AABBMin, node.AABBMax, transRay, payload, mesh.mat, mesh.M);

                for (int z = node.triStart; z < node.triStart - node.leftChild; z++)
                {
                    uint osz = z + mesh.triOffset;

                    Triangle tri = TriangleBuffer[osz];

                    TriangleIntersection(tri, transRay, payload);

                    // TriObjectToWorld(tri, mesh.M, mesh.nM);
                    // TriangleIntersection(tri, ray, payload, mesh.mat);

                    // TriangleIntersection(tri, transRay, ray, payload, mesh.mat, mesh.nM);
                }
            }
            else
            {
                BVHNode leftChild = BVHNodeBuffer[node.leftChild + mesh.nodeOffset];
                BVHNode rightChild = BVHNodeBuffer[node.leftChild + 1 + mesh.nodeOffset];

                float dstA = AABBIntersectionDst(leftChild.AABBMin, leftChild.AABBMax, transRay);
                float dstB = AABBIntersectionDst(rightChild.AABBMin, rightChild.AABBMax, transRay);

                bool isNearestA = dstA <= dstB;
                float dstNear = isNearestA ? dstA : dstB;
                float dstFar = isNearestA ? dstB : dstA;
                int childIndexNear = isNearestA ? node.leftChild : node.leftChild + 1;
                int childIndexFar = isNearestA ? node.leftChild + 1 : node.leftChild;

                if (dstFar < payload.closestT)
                    nodeStack[stackTop++] = childIndexFar + mesh.nodeOffset;
                if (dstNear < payload.closestT)
                    nodeStack[stackTop++] = childIndexNear + mesh.nodeOffset;
            }
        }

        if (payload.hit && payload.closestT < FLT_MAX)
        {
            payload.normal = normalize(mul(mesh.nM, float4(payload.normal, 0)).xyz);
            payload.position = ray.origin + payload.closestT * ray.direction;
            payload.mat = mesh.mat;
        }
    }
}

float3 Shade(Ray ray, uint2 id, uint width, uint height)
{
    float3 col = 0;
    float3 contribution = 1.0;

    uint bounces = _bouncesCount;
    uint stride = width * height * bounces;

    uint seed = (id.y * width + id.x) * bounces;
    seed += (_frameCount - 1) * stride;

    #ifdef USE_RR
    uint i = 0;
    while(true)
    #else
    for (uint i = 0; i < bounces; i++)
    #endif
    {
        seed += i;
        seed *= PCG_Hash(seed);

        #ifdef USE_RR
        float rand = RandomFloat(seed);
        if (rand < _RR)
        {
        #endif

        HitPayload payload = CreateHitPayload();
        TraceRay(ray, payload);

        if (payload.closestT < FLT_MAX)
        {
            if (payload.mat.enableEmission)
            {
                col += payload.mat.emissionColor * contribution;
                break;
            }

            float3 v = -ray.direction;


            float mis = MultipleImportanceSample(seed, v, payload.normal, payload.mat, ray.direction);

            if (payload.mat.texIndex)
                payload.mat.baseColor = Tex0[payload.uv * 2048].rgb;
            // payload.mat.baseColor = float3(1, 0, 0);

            float3 bsdf = DisneyBSDF(payload.normal, v, ray.direction, payload.mat) * max(0, mis);

            contribution *= bsdf;


            // float nv = dot(payload.normal, v);
            float nl = dot(payload.normal, ray.direction);
            // float lv = dot(ray.direction, v);
            // float nh = dot(payload.normal, h);
            // float hl = dot(h, ray.direction);

            float bias = nl < 0 ? -1e-4 : 1e-4;
            ray.origin = payload.position + payload.normal * bias;
        }
        else
        {
            #ifdef USE_SKYBOX
            col += _SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, ray.direction, 0).rgb * contribution;
            #else
            col += _skyColor * contribution;
            #endif
            break;
        }
        #ifdef USE_RR
        }
        else
        {
            col /= _RR;
            break;
        }
        i++;
        #endif
    }

    return col;
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    // float3 col = 0;
    // for (int i = -1; i < 2; i += 2)
    // {
    //     for (int j = -1; j < 2; j += 2)
    //     {
    //         Ray ray = CreateRay(uv + float2(float(i) / width, float(j) / height) * 0.25);
    //         col += Shade(ray, id.xy, width, height);
    //     }
    // }
    // col /= 4.0;

    Ray ray = CreateRay(uv);
    float3 col = Shade(ray, id.xy, width, height);

    if (_cameraType == 1 && _frameCount > 1)
        col = lerp(Result[id.xy].rgb, col, 1.0f / _frameCount);

    Result[id.xy] = float4(col, 1);
    // Result[id.xy] = Tex0[id.xy];
}
